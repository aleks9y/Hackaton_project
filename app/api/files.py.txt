from fastapi import APIRouter, Depends, HTTPException, UploadFile, File as FastAPIFile
from fastapi.responses import FileResponse
from sqlalchemy.orm import selectinload
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List
from pathlib import Path
import os
import uuid

from database.engine import get_session
from database.models import Theme, Course, User, File as ThemeFile
from utils.auth import get_current_user


files_router = APIRouter()

UPLOAD_DIR = Path("uploads/themes")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

MAX_FILE_SIZE = 100 * 1024 * 1024  # 100 MB


@files_router.post("/theme/{theme_id}/uploadfiles")
async def upload_theme_files(
    theme_id: int,
    files: List[UploadFile] = FastAPIFile(...),
    db: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user),
):
    # подтягиваем тему вместе с курсом и владельцем
    result = await db.execute(
        select(Theme)
        .options(selectinload(Theme.course).selectinload(Course.owner))
        .filter(Theme.id == theme_id)
    )
    theme = result.scalar_one_or_none()

    if not theme:
        raise HTTPException(status_code=404, detail="Theme not found")

    # проверка, что пользователь — владелец курса
    if theme.course.owner_id != current_user.id:
        raise HTTPException(
            status_code=403, detail="You are not the owner of this course"
        )

    saved_files = []
    theme_dir = UPLOAD_DIR / str(theme_id)
    theme_dir.mkdir(parents=True, exist_ok=True)

    for upload in files:
        file_id = uuid.uuid4().hex
        safe_name = f"{file_id}_{upload.filename}"
        dest_path = theme_dir / safe_name

        total_size = 0
        try:
            with dest_path.open("wb") as out:
                while True:
                    chunk = await upload.read(1024 * 1024)  # 1 MB
                    if not chunk:
                        break
                    total_size += len(chunk)
                    if total_size > MAX_FILE_SIZE:
                        out.close()
                        dest_path.unlink(missing_ok=True)
                        raise HTTPException(
                            status_code=400,
                            detail=f"File {upload.filename} exceeds 100 MB limit",
                        )
                    out.write(chunk)
        finally:
            await upload.close()

        rel_path = dest_path.as_posix()
        db_file = ThemeFile(
            theme_id=theme_id,
            is_homework=False,
            file_path=rel_path,
        )
        db.add(db_file)
        await db.flush()
        await db.refresh(db_file)

        saved_files.append(
            {
                "id": db_file.id,
                "filename": upload.filename,
                "url": "/" + rel_path.lstrip("/"),
            }
        )

    await db.commit()
    return saved_files


@files_router.get("/theme/{theme_id}/getfiles")
async def get_theme_files(
    theme_id: int,
    db: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user),
):
    result = await db.execute(
        select(Theme)
        .options(selectinload(Theme.course).selectinload(Course.owner))
        .filter(Theme.id == theme_id)
    )
    theme = result.scalar_one_or_none()

    if not theme:
        raise HTTPException(status_code=404, detail="Theme not found")

    if theme.course.owner_id != current_user.id:
        raise HTTPException(
            status_code=403, detail="You are not the owner of this course"
        )

    files_result = await db.execute(
        select(ThemeFile).filter(
            ThemeFile.theme_id == theme_id,
            ThemeFile.is_homework == False,
        )
    )
    files = files_result.scalars().all()

    return [
        {
            "id": f.id,
            "filename": os.path.basename(f.file_path),
            "url": "/" + f.file_path.lstrip("/"),
        }
        for f in files
    ]
